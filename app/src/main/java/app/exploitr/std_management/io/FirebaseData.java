package app.exploitr.std_management.io;

import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import app.exploitr.storetodoor.Objects.FoodObject;
import app.exploitr.storetodoor.functions.majors.DatabaseConstants;

public class FirebaseData {
	private long start_time, end_time;

	private static FirebaseData instance;

	public static FirebaseData getInstance() {
		return instance != null ? instance : (instance = new FirebaseData());
	}

	private FirebaseFirestore db() {
		return DatabaseConstants.getFDB();
	}

	/*Food listing data*/

	public void getMajorFoodList(FoodListListener listListener) {
		List<String> nameList = new ArrayList<>();
		db().collection(DatabaseConstants.MAIN_FOODS).get().addOnCompleteListener(task -> {
			if (task.isSuccessful()) {
				for (DocumentSnapshot snapshots : task.getResult().getDocuments()) {
					nameList.add(snapshots.getId());
				}
				listListener.getFoodList(nameList);
			}
		});
	}

	public void getMinorFoodList(String mode, String selection, FoodListListener listListener) {
		CollectionReference reference = db().collection(DatabaseConstants.MAIN_FOODS)
				.document(mode).collection(selection);

		reference.get().addOnSuccessListener(queryDocumentSnapshots -> {
			ArrayList<FoodObject> objects = new ArrayList<>();
			for (DocumentSnapshot doc : queryDocumentSnapshots.getDocuments()) {
				if (doc.getId().equalsIgnoreCase(DatabaseConstants.TIME_TABLE)) {
					start_time = (Long) doc.get(DatabaseConstants.TIME_TABLE_START);
					end_time = (Long) doc.get(DatabaseConstants.TIME_TABLE_STOP);
				} else if (doc.getId().equalsIgnoreCase(DatabaseConstants.SPECIAL_ITEM)) {
					doc.getReference().collection(DatabaseConstants.SPECIAL_ITEM)
							.get()
							.addOnSuccessListener(qDS_special -> {
								for (DocumentSnapshot doc_special : qDS_special.getDocuments()) {
									FoodObject object = new FoodObject();

									boolean hasSingleOrderable = false;
									boolean hasStockInfo = false;

									object.setSpecial(true);
									object.setMajorFood(doc_special.getId());
									Map<String, Object> allFields = doc_special.getData();

									if (allFields != null) {
										for (Map.Entry<String, Object> entry : allFields.entrySet()) {
											if (entry.getKey().equalsIgnoreCase(DatabaseConstants.ITEM_ID)) {
												object.setItem_id((Long) entry.getValue());
											} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.MIN_ORDER)) {
												object.setMinOrder((Long) entry.getValue());
											} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.ITEM_DESC)) {
												object.setFoodDesc((String) entry.getValue());
											} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.SINGLE_ORDERABLE)) {
												object.setSingleOrderable((Boolean) entry.getValue());
												hasSingleOrderable = true;
											} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.OUT_OF_STOCK)) {
												object.setOutOfStock((Boolean) entry.getValue());
												hasStockInfo = true;
											}else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.IMG_ID)) {
												object.setImg_id((String) entry.getValue());
											}  else {
												object.setPrices(new FoodObject.StorePrice()
														.setPrice((long) entry.getValue())
														.setStore(entry.getKey()));
											}
										}
									}

									if (!hasSingleOrderable)
										object.setSingleOrderable(true);
									if (!hasStockInfo)
										object.setOutOfStock(false);

									for (FoodObject any : objects) {
										if (any.getItem_id() == object.getItem_id())
											return;
									} //rem duplicates idk if possible or what

									objects.add(object);

									listListener.getFoodDetailList(objects, start_time, end_time);
								}
							}).addOnFailureListener(e -> {
					});
				} else {
					FoodObject object = new FoodObject();
					object.setSpecial(false);
					object.setMajorFood(doc.getId());
					Map<String, Object> allFields = doc.getData();

					boolean hasSingleOrderable = false;
					boolean hasStockInfo = false;

					if (allFields != null) {
						for (Map.Entry<String, Object> entry : allFields.entrySet()) {
							if (entry.getKey().equalsIgnoreCase(DatabaseConstants.ITEM_ID)) {
								object.setItem_id((Long) entry.getValue());
							} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.MIN_ORDER)) {
								object.setMinOrder((Long) entry.getValue());
							} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.ITEM_DESC)) {
								object.setFoodDesc((String) entry.getValue());
							} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.SINGLE_ORDERABLE)) {
								object.setSingleOrderable((Boolean) entry.getValue());
								hasSingleOrderable = true;
							} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.OUT_OF_STOCK)) {
								object.setOutOfStock((Boolean) entry.getValue());
								hasStockInfo = true;
							}else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.IMG_ID)) {
								object.setImg_id((String) entry.getValue());
							} else {
								object.setPrices(new FoodObject.StorePrice()
										.setPrice((long) entry.getValue())
										.setStore(entry.getKey()));
							}
						}
					}

					for (FoodObject any : objects) {
						if (any.getItem_id() == object.getItem_id())
							return;
					} //rem duplicates idk if possible or what

					if (!hasSingleOrderable)
						object.setSingleOrderable(true);
					if (!hasStockInfo)
						object.setOutOfStock(false);

					objects.add(object);
				}

				listListener.getFoodDetailList(objects, start_time, end_time);
			}
		}).addOnFailureListener(e -> {
		});
	}

	public void getMinorFoodListNamesInternal(FoodListListener listListener, String mode) {
		List<String> all = new ArrayList<>();
		db().collection(DatabaseConstants.MAIN_FOODS).document(mode).get().addOnCompleteListener(task -> {
			if (task.isSuccessful()) {
				all.addAll(task.getResult().getData().keySet());
			}
			listListener.getFoodList(all);
		});
	}


	public interface FoodListListener {
		void getFoodList(List<String> stringList); // used twice first to fetch the >food list then to >main/other list

		void getFoodDetailList(ArrayList<FoodObject> stringList, long start, long end); //detailed list
	}
}
