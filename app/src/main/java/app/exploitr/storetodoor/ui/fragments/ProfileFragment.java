package app.exploitr.storetodoor.ui.fragments;

import android.Manifest;
import android.app.Activity;
import android.content.Intent;
import android.content.IntentSender;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.core.content.res.ResourcesCompat;
import androidx.fragment.app.Fragment;

import com.amulyakhare.textdrawable.TextDrawable;
import com.google.android.gms.common.api.ApiException;
import com.google.android.gms.common.api.ResolvableApiException;
import com.google.android.gms.location.LocationRequest;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.location.LocationSettingsRequest;
import com.google.android.gms.location.LocationSettingsStatusCodes;
import com.google.android.material.button.MaterialButton;
import com.google.android.material.floatingactionbutton.FloatingActionButton;
import com.google.android.material.textfield.TextInputEditText;
import com.google.firebase.FirebaseException;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.auth.PhoneAuthCredential;
import com.google.firebase.auth.PhoneAuthOptions;
import com.google.firebase.auth.PhoneAuthProvider;
import com.google.firebase.auth.UserProfileChangeRequest;
import com.mukesh.OtpView;

import java.util.concurrent.TimeUnit;

import app.exploitr.leku.LocationPickerActivity;
import app.exploitr.storetodoor.R;
import app.exploitr.storetodoor.functions.majors.DistanceMatrix;
import app.exploitr.storetodoor.functions.majors.LocalDatabase;
import app.exploitr.storetodoor.functions.order_system.LocalOrderSystem;
import app.exploitr.storetodoor.ui.activities.main.SplashScreen;
import de.hdodenhof.circleimageview.CircleImageView;

public class ProfileFragment extends Fragment {

	private static final int MAP_BUTTON_REQUEST_CODE = 24;

	String[] permissions = new String[]{
			Manifest.permission.ACCESS_FINE_LOCATION,
			Manifest.permission.CALL_PHONE};

	private static final int LOCATION_PERM = 420;

	private static final double START_LAT = 22.5756294;
	private static final double START_LON = 88.0103296;

	private boolean isSelecting = false;

	String LATITUDE = "latitude";
	String LONGITUDE = "longitude";
	String LOCATION_ADDRESS = "location_address";

	String primary_phone;
	FirebaseUser user;

	AlertDialog locationConfirmDialogue;

	TextInputEditText displayNameSaved, phone_number_saved, currentLocation, currentLandmark;
	CircleImageView profile_photo_view;

	TextView join_timing_text;

	Button save_info, log_out;
	FloatingActionButton change_address;
	Local_Caller caller;
	AlertDialog alertDialog, alertDialog_later;

	FloatingActionButton photo_edit;

	public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		View root = inflater.inflate(R.layout.fragment_profile, container, false);

		displayNameSaved = root.findViewById(R.id.displayNameSaved);
		phone_number_saved = root.findViewById(R.id.phone_number_saved);

		currentLocation = root.findViewById(R.id.currentLocation);
		currentLandmark = root.findViewById(R.id.currentLandmark);

		profile_photo_view = root.findViewById(R.id.profile_photo_view);

		save_info = root.findViewById(R.id.save_info);
		change_address = root.findViewById(R.id.change_address);
		log_out = root.findViewById(R.id.log_out);

		join_timing_text = root.findViewById(R.id.join_timing_text);
		photo_edit = root.findViewById(R.id.photo_edit);

		user = FirebaseAuth.getInstance().getCurrentUser();
		if (user != null) {
			displayNameSaved.setText(user.getDisplayName());
			phone_number_saved.setText(user.getPhoneNumber());

			primary_phone = user.getPhoneNumber();

			TextDrawable drawable = TextDrawable.builder()
					.beginConfig()
					.width(500)
					.height(500)
					.useFont(ResourcesCompat.getFont(requireActivity(), R.font.bangers))
					.fontSize(300)
					.textColor(ContextCompat.getColor(requireActivity(), R.color.primary))
					.endConfig()
					.buildRect(TextUtils.isEmpty(user.getDisplayName()) ? "?" :
							String.valueOf(user.getDisplayName().charAt(0)), ContextCompat.getColor(requireActivity(), R.color.buttons));

			profile_photo_view.setImageDrawable(drawable);

			long userTime = user.getMetadata().getCreationTimestamp();
			userTime = System.currentTimeMillis() - userTime;

			long year = (TimeUnit.MILLISECONDS.toDays(userTime) / 365);
			long month = (TimeUnit.MILLISECONDS.toDays(userTime) / 28) - (year * 12);
			long day = TimeUnit.MILLISECONDS.toDays(userTime) - month * 28;
			long hour = TimeUnit.MILLISECONDS.toHours(userTime) - day * 24;
			long minute = TimeUnit.MILLISECONDS.toMinutes(userTime) - hour * 60;
			long second = TimeUnit.MILLISECONDS.toSeconds(userTime) - minute * 60;

			StringBuilder builder = new StringBuilder();
			if (year > 0) {
				builder.append(year).append("y ")
						.append(month).append("mon ")
						.append("ago.");
			} else if (month > 0) {
				builder.append(month).append("mon ")
						.append(day).append("d ")
						.append("ago.");
			} else if (day > 0) {
				builder.append(day).append("d ")
						.append(hour).append("hr ")
						.append("ago.");
			} else if (hour > 0) {
				builder.append(hour).append("hr ")
						.append(minute).append("min ")
						.append("ago.");
			} else if (minute > 0) {
				builder.append(minute).append("min ")
						.append(second).append("s ")
						.append("ago.");
			} else if (second > 0) {
				builder.append(second).append("s ")
						.append("ago.");
			}

			join_timing_text.setText(builder.toString());

		} else {/*

		todo highlight tried to fix double-open (fixed)
			Toast.makeText(requireActivity(), "Login First", Toast.LENGTH_SHORT).show();
			startActivity(new Intent(requireActivity(), LoginActivity.class));
			requireActivity().finish();*/
		}

		initiatePermissionCallback();

		change_address.setOnClickListener(v -> pickupLocation());

		photo_edit.setOnClickListener(v -> Toast.makeText(getContext(), "This feature is disabled for now.", Toast.LENGTH_SHORT).show());

		save_info.setOnClickListener(v -> {
			user.updateProfile(new UserProfileChangeRequest.Builder()
					.setDisplayName(displayNameSaved.getText().toString())
					.build());

			Toast.makeText(getContext(), "Updated Profile!" + String.valueOf(Character.toChars(0x2705)), Toast.LENGTH_SHORT).show();

			if (LocalDatabase.getInstance(getContext()).getLandmark() == null || LocalDatabase.getInstance(getContext()).getLandmark().equals("") ||
					LocalDatabase.getInstance(getContext()).getLandmark().equals(getString(R.string.no_address_found)))
				Toast.makeText(getContext(), "Consider adding landmark for better delivery experience!", Toast.LENGTH_SHORT).show();

			if (!primary_phone.equalsIgnoreCase(phone_number_saved.getText().toString())) {
				updatePhone();
			}
		});

		log_out.setOnClickListener(v -> {
			LocalDatabase.getInstance(getContext()).clear();
			LocalOrderSystem.removeOrdersAll(new LocalOrderSystem.LocalOrderSystemListener() {
				@Override
				public void onSuccess() {

				}

				@Override
				public void onFailure() {

				}
			});
			FirebaseAuth.getInstance().signOut();
			startActivity(new Intent(requireActivity(), SplashScreen.class));
			if (!requireActivity().isFinishing())
				requireActivity().finishAndRemoveTask();
		});

		((AppCompatActivity) requireActivity()).getSupportActionBar()
				.setTitle("Setup Profile");
		((AppCompatActivity) requireActivity()).getSupportActionBar()
				.setSubtitle(null);

		setupTextWatcher();

		return root;
	}

	private void setupTextWatcher() {
		currentLocation.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {

			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {

			}

			@Override
			public void afterTextChanged(Editable s) {
				new Handler(Looper.getMainLooper())
						.postDelayed(() -> LocalDatabase.getInstance(getContext()).setLastAddress(s.toString()), 500);
			}
		});
		currentLandmark.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {

			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {

			}

			@Override
			public void afterTextChanged(Editable s) {
				new Handler(Looper.getMainLooper())
						.postDelayed(() -> LocalDatabase.getInstance(getContext()).setLandmark(s.toString()), 500);
			}
		});
	}

	private void initiatePermissionCallback() {
		boolean anyNotGranted = false;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
			for (String perm : permissions) {
				anyNotGranted = ContextCompat.checkSelfPermission(requireActivity(), perm)
						!= PackageManager.PERMISSION_GRANTED;
				break;
			}
		}

		if (anyNotGranted) {
			requestPermissions(permissions, LOCATION_PERM);
		} else {
			pickupInitiator();
		}
	}

	private void pickupInitiator() {
		if (LocalDatabase.getInstance(getContext()).getLandmark() != null)
			currentLandmark.setText(LocalDatabase.getInstance(getContext()).getLandmark());
		if (LocalDatabase.getInstance(requireActivity()).getLastAddress() != null) {
			currentLocation.setText(LocalDatabase.getInstance(requireActivity()).getLastAddress());
		} else {
			pickupLocation();
		}
	}

	private void pickupLocation() {
		LocationRequest locationRequest = LocationRequest.create();
		locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);
		LocationSettingsRequest.Builder builder = new LocationSettingsRequest.Builder()
				.addLocationRequest(locationRequest);
		LocationServices.getSettingsClient(requireActivity()).checkLocationSettings(builder.build())
				.addOnCompleteListener(task -> {
					try {
						task.getResult(ApiException.class);
						// All location settings are satisfied. The client can initialize location requests here.
						pickupLocationInternal();
					} catch (ApiException exception) {
						switch (exception.getStatusCode()) {
							case LocationSettingsStatusCodes.RESOLUTION_REQUIRED:
								try {
									ResolvableApiException resolvable = (ResolvableApiException) exception;
									resolvable.startResolutionForResult(
											requireActivity(),
											LocationRequest.PRIORITY_HIGH_ACCURACY);
								} catch (IntentSender.SendIntentException | ClassCastException ignored) {
									Toast.makeText(requireActivity(), "Please turn on GPS", Toast.LENGTH_SHORT).show();
								}
								break;
							case LocationSettingsStatusCodes.SETTINGS_CHANGE_UNAVAILABLE:
								Toast.makeText(requireActivity(), "GPS unavailable, choose location manually", Toast.LENGTH_SHORT).show();
								pickupLocationInternal();
								break;
						}
					}
				});
	}

	private void pickupLocationInternal() {
		if (requireActivity() != null && !isSelecting) {
			isSelecting = true;
			Intent locationPickerIntent = new LocationPickerActivity.Builder()
					.withLocation(START_LAT, START_LON)
					.build(requireActivity());
			startActivityForResult(locationPickerIntent, MAP_BUTTON_REQUEST_CODE);
		}
	}

	@Override
	public void onPause() {
		if (locationConfirmDialogue != null && locationConfirmDialogue.isShowing())
			locationConfirmDialogue.dismiss();

		if (alertDialog != null && alertDialog.isShowing())
			alertDialog.dismiss();

		if (alertDialog_later != null && alertDialog_later.isShowing())
			alertDialog_later.dismiss();
		super.onPause();
	}

	private void fetchLocationAndVerify(Intent data) {
		double latitude = data.getDoubleExtra(LATITUDE, 0.0);
		double longitude = data.getDoubleExtra(LONGITUDE, 0.0);
		String address = data.getStringExtra(LOCATION_ADDRESS);

		if (latitude == 0d || longitude == 0d) {
			Toast.makeText(getContext(), "Location error, try new one", Toast.LENGTH_SHORT).show();
			pickupLocationInternal();
			return;
		}

		double distance = Math.ceil(DistanceMatrix.distance(START_LAT, START_LON, latitude, longitude, 'K'));

		if (distance <= 10) {
			locationConfirmDialogue = new AlertDialog.Builder(requireActivity())
					.setTitle("Confirm Location ?")
					.setMessage(address)
					.setCancelable(false)
					.setPositiveButton("Yes", (dialog, which) -> {
						LocalDatabase.getInstance(requireActivity())
								.setLastAddress(address)
								.setLatitude(latitude)
								.setLongitude(longitude)
								.setDistance(distance);
						System.out.println("Distance = " + (int) distance + " km(approx)");
						currentLocation.setText(address);
						currentLandmark.setText(LocalDatabase.getInstance(getContext()).getLandmark());
					})
					.setNegativeButton("Reset", (dialog, which) -> pickupLocationInternal())
					.create();
		} else {
			locationConfirmDialogue = new AlertDialog.Builder(requireActivity())
					.setTitle("Oops")
					.setMessage("We're not currently delivering here at the moment\nPlease try again or try another location!")
					.setCancelable(false)
					.setPositiveButton("Ok", (dialog, which) -> pickupLocationInternal())
					.create();
		}

		locationConfirmDialogue.show();

		if (requireActivity().isFinishing() && !locationConfirmDialogue.isShowing())
			locationConfirmDialogue.show();
	}

	@Override
	public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
		switch (requestCode) {
			case MAP_BUTTON_REQUEST_CODE: {
				isSelecting = false;
				if (resultCode == Activity.RESULT_CANCELED) {
					Toast.makeText(requireActivity(), "Delivery location is needed", Toast.LENGTH_SHORT).show();
					pickupLocationInternal();
				} else if (resultCode == Activity.RESULT_OK) {
					if (data != null) {
						fetchLocationAndVerify(data);
					} else {
						pickupLocationInternal();
					}
				}
				break;
			}
			case LocationRequest.PRIORITY_HIGH_ACCURACY: {
				if (resultCode == Activity.RESULT_CANCELED) {
					Toast.makeText(requireActivity(), "Location Access Required", Toast.LENGTH_SHORT).show();
					pickupLocation();
				} else if (resultCode == Activity.RESULT_OK) {
					pickupLocationInternal();
				}
				break;
			}
		}
		super.onActivityResult(requestCode, resultCode, data);
	}

	@Override
	public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
		boolean granted = false;
		for (int result : grantResults) {
			if (requestCode == LOCATION_PERM && result != PackageManager.PERMISSION_GRANTED) {
				Toast.makeText(requireActivity(), "Permission must be granted to select delivery location", Toast.LENGTH_LONG).show();
				granted = false;
				initiatePermissionCallback();
				break;
			} else
				granted = true;
		}

		if (granted)
			pickupInitiator();

		super.onRequestPermissionsResult(requestCode, permissions, grantResults);
	}

	public void startLogin() {
		FirebaseAuth mAuth = FirebaseAuth.getInstance();

		String phone_number_text = phone_number_saved.getText().toString();
		if (!phone_number_text.contains("+91"))
			phone_number_text = "+91" + phone_number_text;

		PhoneAuthOptions options =
				PhoneAuthOptions.newBuilder(mAuth)
						.setPhoneNumber(phone_number_text)
						.setTimeout(60L, TimeUnit.SECONDS)
						.setActivity(requireActivity())
						.setCallbacks(mCallbacks(mAuth))
						.build();
		PhoneAuthProvider.verifyPhoneNumber(options);
		Toast.makeText(requireActivity(), "Please wait for OTP to be sent!", Toast.LENGTH_LONG).show();
	}

	private PhoneAuthProvider.OnVerificationStateChangedCallbacks mCallbacks(FirebaseAuth auth) {
		return new PhoneAuthProvider.OnVerificationStateChangedCallbacks() {

			@Override
			public void onCodeSent(@NonNull String signature, @NonNull PhoneAuthProvider.ForceResendingToken forceResendingToken) {
				Toast.makeText(requireActivity(), "Verification Code Sent", Toast.LENGTH_SHORT).show();
				showOTPMenu(signature, auth);
				super.onCodeSent(signature, forceResendingToken);
			}

			@Override
			public void onCodeAutoRetrievalTimeOut(@NonNull String s) {
				caller.timeout();
				Toast.makeText(requireActivity(), "Verification Timed Out!", Toast.LENGTH_SHORT).show();
				super.onCodeAutoRetrievalTimeOut(s);
			}

			@Override
			public void onVerificationCompleted(@NonNull PhoneAuthCredential phoneAuthCredential) {
				Toast.makeText(requireActivity(), "Logged in!", Toast.LENGTH_SHORT).show();
				tryToVerify(auth, phoneAuthCredential);
			}

			@Override
			public void onVerificationFailed(@NonNull FirebaseException e) {
				Toast.makeText(requireActivity(), "Can't save phone, please try again", Toast.LENGTH_SHORT).show();
			}
		};
	}

	private void tryToVerify(FirebaseAuth mAuth, PhoneAuthCredential credential) {
		mAuth.signInWithCredential(credential)
				.addOnCompleteListener(requireActivity(), task -> {
					if (task.isSuccessful()) {
						updatePhoneInternal(credential);
					} else {
						Toast.makeText(getContext(), "Verification Failed", Toast.LENGTH_SHORT).show();
					}
				});
	}

	private void tryToVerify(String signature, FirebaseAuth auth, String otp) {
		PhoneAuthCredential credential = PhoneAuthProvider.getCredential(signature, otp);
		auth.signInWithCredential(credential).addOnSuccessListener(authResult ->
				updatePhoneInternal(credential))
				.addOnFailureListener(e -> Toast.makeText(getContext(), "Wrong OTP", Toast.LENGTH_SHORT).show());
	}

	private void updatePhone() {
		startLogin();
	}

	private void updatePhoneInternal(PhoneAuthCredential credential) {
		if (user != null) {
			user.updatePhoneNumber(credential).addOnCompleteListener(task ->
					Toast.makeText(requireActivity(), task.isSuccessful() ? "Phone Updated!" : "Phone Updation Failed", Toast.LENGTH_SHORT).show());
		}
	}

	private void showOTPMenu(String signature, FirebaseAuth auth) {
		View progressView = getLayoutInflater().inflate(R.layout.otp_dialogue, null);

		MaterialButton enter_otp = progressView.findViewById(R.id.enter_otp);
		MaterialButton otp_cancel = progressView.findViewById(R.id.otp_cancel);

		enter_otp.setOnClickListener(v -> caller.timeout());
		otp_cancel.setOnClickListener(v -> {
			if (alertDialog != null && alertDialog.isShowing())
				alertDialog.dismiss();
		});

		alertDialog = new AlertDialog.Builder(requireActivity())
				.setView(progressView)
				.setCancelable(false)
				.create();

		caller = () -> {
			alertDialog.dismiss();

			View progressView_later = getLayoutInflater().inflate(R.layout.otp_dialogue_2nd, null);
			alertDialog_later = new AlertDialog.Builder(requireActivity())
					.setView(progressView_later)
					.setCancelable(false)
					.create();

			OtpView otp_view = progressView_later.findViewById(R.id.otp_view);

			otp_view.setOtpCompletionListener(otp -> tryToVerify(signature, auth, otp));

			alertDialog_later.show();
		};

		alertDialog.show();
	}

	private interface Local_Caller {
		void timeout();
	}
}