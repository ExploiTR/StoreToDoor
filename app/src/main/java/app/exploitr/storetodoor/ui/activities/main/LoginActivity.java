package app.exploitr.storetodoor.ui.activities.main;

import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.location.Address;
import android.location.Geocoder;
import android.location.Location;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Looper;
import android.provider.Settings;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.LinearLayoutCompat;
import androidx.core.app.ActivityCompat;

import com.airbnb.lottie.LottieAnimationView;
import com.google.android.gms.common.ConnectionResult;
import com.google.android.gms.common.GoogleApiAvailability;
import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationCallback;
import com.google.android.gms.location.LocationRequest;
import com.google.android.gms.location.LocationResult;
import com.google.android.gms.location.LocationServices;
import com.google.android.material.button.MaterialButton;
import com.google.android.material.textfield.TextInputEditText;
import com.google.firebase.FirebaseException;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.PhoneAuthCredential;
import com.google.firebase.auth.PhoneAuthOptions;
import com.google.firebase.auth.PhoneAuthProvider;
import com.mukesh.OtpView;

import java.io.IOException;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

import app.exploitr.storetodoor.R;
import app.exploitr.storetodoor.functions.majors.LocalDatabase;

public class LoginActivity extends AppCompatActivity {

	private Local_Caller caller;
	boolean canLogin = true;

	TextInputEditText phone_number;
	Button login;
	AlertDialog perm_d, perm_login, alertDialog, alertDialog_later;
	ImageView std_logo;
	LinearLayoutCompat phone_login_container;
	LottieAnimationView anime;

	private static final int LOCATION_PERM = 420;
	private static final int LOCATION_PERM_BACK = 421;
	private static final int LOCATION_PERM_MANUAL = 530;

	FusedLocationProviderClient fusedLocationClient;
	LocationRequest locationRequest;
	LocationCallback locationCallback;

	String[] permissions = new String[]{
			Manifest.permission.ACCESS_FINE_LOCATION,
			Manifest.permission.ACCESS_COARSE_LOCATION,
			Manifest.permission.ACCESS_NETWORK_STATE,
			Manifest.permission.CALL_PHONE};

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_login);

		phone_number = findViewById(R.id.phone_number);
		login = findViewById(R.id.login);
		std_logo = findViewById(R.id.std_logo);
		phone_login_container = findViewById(R.id.phone_login_container);
		anime = findViewById(R.id.anime);

		login.setOnClickListener(this::startLogin);

		checkGooglePlayServices();
		Animation animation =
				AnimationUtils.loadAnimation(getApplicationContext(), R.anim.move);
		std_logo.startAnimation(animation);
	}

	private void createLocationListener() {
		fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);

		locationRequest = LocationRequest.create()
				.setInterval(100)
				.setFastestInterval(3000)
				.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)
				.setMaxWaitTime(5000)
				.setWaitForAccurateLocation(true);

		locationCallback = new LocationCallback() {
			@Override
			public void onLocationResult(@NonNull LocationResult locationResult) {
				double lat = 0d, lon = 0d;
				float accuracy = 0f;
				for (Location location : locationResult.getLocations()) {
					if (location.getAccuracy() > accuracy) {
						lat = location.getLatitude();
						lon = location.getLongitude();
						accuracy = location.getAccuracy();
					}
				}

				final double lat_f = lat;
				final double lon_f = lon;
				getLocationUpdate(lat, lon, bestMatch -> {
					if (bestMatch == null) {
						//todo highlight
						return;
					}
					fusedLocationClient.removeLocationUpdates(this);
					LocalDatabase.getInstance(getApplicationContext()).setLastAddress(bestMatch.getAddressLine(0));
					LocalDatabase.getInstance(getApplicationContext()).setLatitude(lat_f);
					LocalDatabase.getInstance(getApplicationContext()).setLongitude(lon_f);

					Animation animation_out =
							AnimationUtils.loadAnimation(getApplicationContext(), R.anim.move_out);
					anime.startAnimation(animation_out);
					anime.setVisibility(View.GONE);

					Animation animation_in =
							AnimationUtils.loadAnimation(getApplicationContext(), R.anim.move);
					phone_login_container.setVisibility(View.VISIBLE);
					phone_login_container.startAnimation(animation_in);
				});
			}
		};

		if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
				!= PackageManager.PERMISSION_GRANTED &&
				ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION)
						!= PackageManager.PERMISSION_GRANTED) {
			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
				initiatePermissionCallback();
			}
		}
		fusedLocationClient.requestLocationUpdates(locationRequest, locationCallback, Looper.myLooper());
	}

	private void getLocationUpdate(double lat, double lon, Location_Caller caller) {
		new Thread(() -> {
			Geocoder geoCoder = new Geocoder(getApplicationContext());
			List<Address> matches = null;
			try {
				matches = geoCoder.getFromLocation(lat, lon, 1);
			} catch (IOException e) {
				e.printStackTrace();
			}
			final List<Address> matches_ = matches;
			runOnUiThread(() -> caller.onFound(matches_.get(0)));
		}).start();
	}

	private void checkGooglePlayServices() {
		switch (GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(this)) {
			case ConnectionResult.SERVICE_MISSING:
			case ConnectionResult.SERVICE_INVALID: {
				GoogleApiAvailability.getInstance().makeGooglePlayServicesAvailable(this);
				break;
			}
			case ConnectionResult.SERVICE_DISABLED: {
				Toast.makeText(this, "Enable Google Play Services", Toast.LENGTH_SHORT).show();
				GoogleApiAvailability.getInstance().makeGooglePlayServicesAvailable(this);
				finish();
				break;
			}
			case ConnectionResult.SERVICE_MISSING_PERMISSION: {
				Toast.makeText(this, "Enable Google Play Services", Toast.LENGTH_SHORT).show();
				GoogleApiAvailability.getInstance().makeGooglePlayServicesAvailable(this);
				break;
			}
			case ConnectionResult.SERVICE_VERSION_UPDATE_REQUIRED: {
				Toast.makeText(this, "Update Google Play Services", Toast.LENGTH_SHORT).show();
				GoogleApiAvailability.getInstance().makeGooglePlayServicesAvailable(this);
				break;
			}
			case ConnectionResult.SERVICE_UPDATING: {
				Toast.makeText(this, "Play Services is updating, some features might not be available right now.", Toast.LENGTH_SHORT).show();
				break;
			}
			default:
				break;
		}
	}

	@Override
	protected void onResume() {
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
			initiatePermissionCallback();
		}
		super.onResume();
	}

	public void startLogin(View view) {
		if (!canLogin) {
			perm_login = new AlertDialog.Builder(LoginActivity.this)
					.setTitle("Error")
					.setMessage("Application will not work without permissions, would you like to grant manually?")
					.setPositiveButton("Okay", (dialog, which) -> {
						Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
						Uri uri = Uri.fromParts("package", getPackageName(), null);
						intent.setData(uri);
						startActivityForResult(intent, LOCATION_PERM_MANUAL);     // Comment 3.
					}).setNegativeButton("Exit", (dialog, which) ->
							finishAndRemoveTask())
					.create();
			if (!this.isFinishing() && perm_login != null && !perm_login.isShowing())
				perm_login.show();

			return;
		}

		FirebaseAuth mAuth = FirebaseAuth.getInstance();

		String phone_number_text = Objects.requireNonNull(phone_number.getText()).toString();
		if (phone_number_text.equals("")) {
			Toast.makeText(this, "Enter a valid phone number", Toast.LENGTH_SHORT).show();
			return;
		}
		if (!phone_number_text.contains("+91"))
			phone_number_text = "+91" + phone_number_text;

		PhoneAuthOptions options =
				PhoneAuthOptions.newBuilder(mAuth)
						.setPhoneNumber(phone_number_text)
						.setTimeout(60L, TimeUnit.SECONDS)
						.setActivity(this)
						.setCallbacks(mCallbacks(mAuth))
						.build();
		PhoneAuthProvider.verifyPhoneNumber(options);
		Toast.makeText(this, "Please wait for OTP to be sent!", Toast.LENGTH_LONG).show();
	}

	private PhoneAuthProvider.OnVerificationStateChangedCallbacks mCallbacks(FirebaseAuth auth) {
		return new PhoneAuthProvider.OnVerificationStateChangedCallbacks() {

			@Override
			public void onCodeSent(@NonNull String signature, @NonNull PhoneAuthProvider.ForceResendingToken forceResendingToken) {
				Toast.makeText(LoginActivity.this, "Verification Code Sent", Toast.LENGTH_SHORT).show();
				showOTPMenu(signature, auth);
				super.onCodeSent(signature, forceResendingToken);
			}

			@Override
			public void onCodeAutoRetrievalTimeOut(@NonNull String s) {
				caller.timeout();
				super.onCodeAutoRetrievalTimeOut(s);
			}

			@Override
			public void onVerificationCompleted(@NonNull PhoneAuthCredential phoneAuthCredential) {
				Toast.makeText(LoginActivity.this, "Logged in!", Toast.LENGTH_SHORT).show();
				tryToVerify(auth, phoneAuthCredential);
				//todo highlight was removed for testing replication issue moveIntoMainMenu();
			}

			@Override
			public void onVerificationFailed(@NonNull FirebaseException e) {
				e.printStackTrace();
				Toast.makeText(LoginActivity.this, "Can't verify, please try again", Toast.LENGTH_SHORT).show();
			}
		};
	}

	private void showOTPMenu(String signature, FirebaseAuth auth) {
		View progressView = getLayoutInflater().inflate(R.layout.otp_dialogue, null);

		MaterialButton enter_otp = progressView.findViewById(R.id.enter_otp);
		MaterialButton otp_cancel = progressView.findViewById(R.id.otp_cancel);

		enter_otp.setOnClickListener(v -> caller.timeout());
		otp_cancel.setOnClickListener(v -> {
			if (alertDialog != null && alertDialog.isShowing())
				alertDialog.dismiss();
		});

		alertDialog = new AlertDialog.Builder(this)
				.setView(progressView)
				.setCancelable(false)
				.create();

		caller = () -> {
			alertDialog.dismiss();

			View progressView_later = getLayoutInflater().inflate(R.layout.otp_dialogue_2nd, null);
			alertDialog_later = new AlertDialog.Builder(LoginActivity.this)
					.setView(progressView_later)
					.setCancelable(false)
					.create();

			OtpView otp_view = progressView_later.findViewById(R.id.otp_view);

			otp_view.setOtpCompletionListener(otp -> tryToVerify(signature, auth, otp));

			alertDialog_later.show();
		};

		alertDialog.show();
	}

	private void tryToVerify(FirebaseAuth mAuth, PhoneAuthCredential credential) {
		mAuth.signInWithCredential(credential)
				.addOnCompleteListener(this, task -> {
					if (task.isSuccessful()) {
						Toast.makeText(LoginActivity.this, "Logged in!", Toast.LENGTH_SHORT).show();
						moveIntoMainMenu();
					} else {
						Toast.makeText(LoginActivity.this, "Verification Failed", Toast.LENGTH_SHORT).show();
					}
				});
	}

	private void tryToVerify(String signature, FirebaseAuth auth, String otp) {
		PhoneAuthCredential credential = PhoneAuthProvider.getCredential(signature, otp);
		auth.signInWithCredential(credential).addOnSuccessListener(authResult -> {
			Toast.makeText(LoginActivity.this, "Logged in!", Toast.LENGTH_SHORT).show();
			moveIntoMainMenu();
		}).addOnFailureListener(e -> {
			Toast.makeText(LoginActivity.this, "Wrong OTP", Toast.LENGTH_SHORT).show();
		});
	}

	@Override
	protected void onPause() {
		if (alertDialog != null && alertDialog.isShowing())
			alertDialog.dismiss();

		if (alertDialog_later != null && alertDialog_later.isShowing())
			alertDialog_later.dismiss();
		super.onPause();
	}

	private void moveIntoMainMenu() {
		startActivity(new Intent(this, MainActivity.class));
		finish();
		storePhone();
	}

	private void storePhone() {
		LocalDatabase.getInstance(this).setPhone(phone_number.getText().toString());
	}

	private interface Local_Caller {
		void timeout();
	}

	private interface Location_Caller {
		void onFound(Address bestMatch);
	}

	@RequiresApi(api = Build.VERSION_CODES.M)
	private void initiatePermissionCallback() {
		boolean all_granted = true;

		for (String perm : permissions) {
			boolean granted = ActivityCompat.checkSelfPermission(LoginActivity.this, perm) ==
					PackageManager.PERMISSION_GRANTED;

			if (!granted) {
				all_granted = false;
				ActivityCompat.requestPermissions(LoginActivity.this,
						permissions,
						LOCATION_PERM);
				break;
			}
		}
		if (all_granted) {
			canLogin = true;
			createLocationListener();
		}
	}

	@RequiresApi(api = Build.VERSION_CODES.M)
	@Override
	public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
		if (requestCode == LOCATION_PERM) {
			for (int result : grantResults) {
				if (result != PackageManager.PERMISSION_GRANTED) {
					Toast.makeText(LoginActivity.this, "Permissions must be granted for app to work fully functional.",
							Toast.LENGTH_SHORT).show();
					canLogin = false;
				} else {
					canLogin = true;
					createLocationListener();
				}
			}
		}
		super.onRequestPermissionsResult(requestCode, permissions, grantResults);
	}

}