package app.exploitr.storetodoor.ui.activities.others;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.google.android.material.card.MaterialCardView;
import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;

import java.util.ArrayList;
import java.util.Map;

import app.exploitr.storetodoor.Objects.FoodObject;
import app.exploitr.storetodoor.R;
import app.exploitr.storetodoor.adapters.others.MainFoodsAdapter;
import app.exploitr.storetodoor.functions.majors.DatabaseConstants;
import app.exploitr.storetodoor.functions.order_system.LocalOrderSystem;

public class FoodListActivity extends AppCompatActivity {

	public static final String FOOD_NAME_DESC = "food_names";

	RecyclerView mainFoods;
	MainFoodsAdapter adapter;
	TextView timing;
	MaterialCardView card_timing;
	ProgressBar progress_loading_foods;
	TextView progress_loading_foods_text, out_of_stock_text;

	String mainFoodType, subFoodType;


	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_food_list);

		Intent intent = getIntent();
		int food_id = intent.getIntExtra(FOOD_NAME_DESC, -1);

		if (getSupportActionBar() != null)
			getSupportActionBar().setTitle(DatabaseConstants.getFoodName(food_id));

		mainFoods = findViewById(R.id.mainFoods);
		timing = findViewById(R.id.timing_order);
		card_timing = findViewById(R.id.card_timing);
		progress_loading_foods = findViewById(R.id.progress_loading_foods);
		progress_loading_foods_text = findViewById(R.id.progress_loading_foods_text);
		out_of_stock_text = findViewById(R.id.out_of_stock_text);

		FirebaseFirestore db = DatabaseConstants.getFDB();
		CollectionReference reference;

		switch (food_id) {
			case DatabaseConstants.FOOD_BIRYANI: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_MAIN)
						.collection("biryani");
				mainFoodType = DatabaseConstants.FOODS_MAIN;
				subFoodType = "biryani";
				break;
			}
			case DatabaseConstants.FOOD_CHOW: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_MAIN)
						.collection("chow");
				mainFoodType = DatabaseConstants.FOODS_MAIN;
				subFoodType = "chow";
				break;
			}
			case DatabaseConstants.FOOD_SNACK: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_MAIN)
						.collection("snacks");
				mainFoodType = DatabaseConstants.FOODS_MAIN;
				subFoodType = "snacks";
				break;
			}
			case DatabaseConstants.FOOD_ROLLS: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_MAIN)
						.collection("rolls");
				mainFoodType = DatabaseConstants.FOODS_MAIN;
				subFoodType = "rolls";
				break;
			}
			case DatabaseConstants.FOOD_RICE: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_MAIN)
						.collection("rice");
				mainFoodType = DatabaseConstants.FOODS_MAIN;
				subFoodType = "rice";
				break;
			}
			case DatabaseConstants.FOOD_FISH_CHICK: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_MAIN)
						.collection("chicken_fish");
				mainFoodType = DatabaseConstants.FOODS_MAIN;
				subFoodType = "chicken_fish";
				break;
			}
			case DatabaseConstants.FOOD_PANEER: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_MAIN)
						.collection("paneer");
				mainFoodType = DatabaseConstants.FOODS_MAIN;
				subFoodType = "paneer";
				break;
			}
			case DatabaseConstants.FOOD_MUTTON: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_MAIN)
						.collection("mutton");
				mainFoodType = DatabaseConstants.FOODS_MAIN;
				subFoodType = "mutton";
				break;
			}
			case DatabaseConstants.FOOD_LUNCH: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_MAIN)
						.collection("lunch");
				mainFoodType = DatabaseConstants.FOODS_MAIN;
				subFoodType = "lunch";
				break;
			}
			case DatabaseConstants.FOOD_DINNER: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_MAIN)
						.collection("dinner");
				mainFoodType = DatabaseConstants.FOODS_MAIN;
				subFoodType = "dinner";
				break;
			}
			case DatabaseConstants.FOOD_SPECIAL: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_OTHERS)
						.collection("special_combos");
				mainFoodType = DatabaseConstants.FOODS_OTHERS;
				subFoodType = "special_combos";
				break;
			}
			case DatabaseConstants.FOOD_CHOCOLATE: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_OTHERS)
						.collection("chocolate");
				mainFoodType = DatabaseConstants.FOODS_OTHERS;
				subFoodType = "chocolate";
				break;
			}
			case DatabaseConstants.FOOD_DRINKS: {
				reference = db.collection(DatabaseConstants.MAIN_FOODS)
						.document(DatabaseConstants.FOODS_OTHERS)
						.collection("drinks");
				mainFoodType = DatabaseConstants.FOODS_OTHERS;
				subFoodType = "drinks";
				break;
			}
			default: {
				reference = null;
			}
		}

		if (reference == null)
			return;


		reference.get().addOnSuccessListener(queryDocumentSnapshots -> {

			ArrayList<FoodObject> objects = new ArrayList<>();
			long start_time = 0, end_time = 0;

			for (DocumentSnapshot doc : queryDocumentSnapshots.getDocuments()) {
				if (doc.getId().equalsIgnoreCase(DatabaseConstants.TIME_TABLE)) {
					start_time = (Long) doc.get(DatabaseConstants.TIME_TABLE_START);
					end_time = (Long) doc.get(DatabaseConstants.TIME_TABLE_STOP);
				} else if (doc.getId().equalsIgnoreCase(DatabaseConstants.SPECIAL_ITEM)) {
					doc.getReference().collection(DatabaseConstants.SPECIAL_ITEM)
							.get()
							.addOnSuccessListener(qDS_special -> {
								for (DocumentSnapshot doc_special : qDS_special.getDocuments()) {
									FoodObject object = new FoodObject();

									boolean hasSingleOrderable = false;
									boolean hasStockInfo = false;

									object.setSpecial(true);
									object.setMajorFood(doc_special.getId());
									Map<String, Object> allFields = doc_special.getData();

									if (allFields != null) {
										for (Map.Entry<String, Object> entry : allFields.entrySet()) {
											if (entry.getKey().equalsIgnoreCase(DatabaseConstants.ITEM_ID)) {
												object.setItem_id((Long) entry.getValue());
											} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.MIN_ORDER)) {
												object.setMinOrder((Long) entry.getValue());
											} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.ITEM_DESC)) {
												object.setFoodDesc((String) entry.getValue());
											} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.SINGLE_ORDERABLE)) {
												object.setSingleOrderable((Boolean) entry.getValue());
												hasSingleOrderable = true;
											} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.OUT_OF_STOCK)) {
												object.setOutOfStock((Boolean) entry.getValue());
												hasStockInfo = true;
											} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.IMG_ID)) {
												object.setImg_id((String) entry.getValue());
											} else {
												object.setPrices(new FoodObject.StorePrice()
														.setPrice((long) entry.getValue())
														.setStore(entry.getKey()));
											}
										}
									}

									if (!hasSingleOrderable)
										object.setSingleOrderable(true);
									if (!hasStockInfo)
										object.setOutOfStock(false);

									if (!object.isOutOfStock()) {
										objects.add(object);
										if (adapter != null)
											adapter.notifyDataSetChanged();
									}
								}
							}).addOnFailureListener(e -> Toast.makeText(this, "Failed to load special items!", Toast.LENGTH_SHORT).show());
				} else {
					FoodObject object = new FoodObject();
					object.setSpecial(false);
					object.setMajorFood(doc.getId());
					Map<String, Object> allFields = doc.getData();

					boolean hasSingleOrderable = false;
					boolean hasStockInfo = false;

					if (allFields != null) {
						for (Map.Entry<String, Object> entry : allFields.entrySet()) {
							if (entry.getKey().equalsIgnoreCase(DatabaseConstants.ITEM_ID)) {
								object.setItem_id((Long) entry.getValue());
							} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.MIN_ORDER)) {
								object.setMinOrder((Long) entry.getValue());
							} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.ITEM_DESC)) {
								object.setFoodDesc((String) entry.getValue());
							} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.SINGLE_ORDERABLE)) {
								object.setSingleOrderable((Boolean) entry.getValue());
								hasSingleOrderable = true;
							} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.OUT_OF_STOCK)) {
								object.setOutOfStock((Boolean) entry.getValue());
								hasStockInfo = true;
							} else if (entry.getKey().equalsIgnoreCase(DatabaseConstants.IMG_ID)) {
								object.setImg_id((String) entry.getValue());
							} else {
								object.setPrices(new FoodObject.StorePrice()
										.setPrice((long) entry.getValue())
										.setStore(entry.getKey()));
							}
						}
					}

					if (!hasSingleOrderable)
						object.setSingleOrderable(true);
					if (!hasStockInfo)
						object.setOutOfStock(false);

					if (!object.isOutOfStock()) {
						objects.add(object);
						if (adapter != null)
							adapter.notifyDataSetChanged();
					}
				}
			}

			timing.setText(new StringBuilder("Order timing : " + getTimingText(start_time) + " to " + getTimingText(end_time)));
			card_timing.setVisibility(View.VISIBLE);

			out_of_stock_text.setVisibility(objects.size() == 0 ? View.VISIBLE : View.INVISIBLE);

			adapter = new MainFoodsAdapter(objects, start_time, end_time,
					FoodListActivity.this, mainFoodType, subFoodType,
					(main_select, item_id, quantity, min, store, single) -> {
						LocalOrderSystem.addOrders(objects.get(main_select), item_id, quantity, min, store, single);
						Toast.makeText(FoodListActivity.this, "Added to cart", Toast.LENGTH_SHORT).show();
					});

			mainFoods.setAdapter(adapter);
			mainFoods.setLayoutManager(new LinearLayoutManager(this));
			adapter.notifyDataSetChanged();

			progress_loading_foods.setVisibility(View.INVISIBLE);
			progress_loading_foods_text.setVisibility(View.INVISIBLE);
		}).addOnFailureListener(e -> Toast.makeText(FoodListActivity.this, "Error", Toast.LENGTH_SHORT).show());
	}

	private static String getTimingText(long time) {
		return time > 12 ? time - 12 + "PM" : time + "AM";
	}
}