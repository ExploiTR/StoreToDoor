package app.exploitr.storetodoor.ui.activities.others;

import android.annotation.SuppressLint;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.AppCompatTextView;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.bumptech.glide.Glide;
import com.google.android.material.card.MaterialCardView;
import com.google.firebase.firestore.DocumentSnapshot;
import com.wdullaer.materialdatetimepicker.time.TimePickerDialog;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import app.exploitr.storetodoor.Objects.LocalOrders;
import app.exploitr.storetodoor.Objects.OfferManager;
import app.exploitr.storetodoor.R;
import app.exploitr.storetodoor.adapters.home.CartAdapter;
import app.exploitr.storetodoor.functions.majors.DatabaseConstants;
import app.exploitr.storetodoor.functions.majors.FirebaseAccess;
import app.exploitr.storetodoor.functions.majors.LocalDatabase;
import app.exploitr.storetodoor.functions.order_system.FoodOrderManager;
import app.exploitr.storetodoor.functions.order_system.LocalOrderSystem;

public class CartActivity extends AppCompatActivity implements TimePickerDialog.OnTimeSetListener {

	RecyclerView recyclerView;
	Button order_success;

	AppCompatTextView order_address,
			payment_mode_change,
			subtotal_price,
			offers_applied_price,
			shipping_price,
			total_price_cart,
			order_qual_text;

	CartAdapter adapter;

	AlertDialog paymentDialogue, g_pay_dialogue, offer_Dialogue;

	private long start;
	private long end;
	private long total_charge_to_pay = 0L;

	private static String reason = "No reason!";

	@SuppressLint("NotifyDataSetChanged")
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_cart);

		recyclerView = findViewById(R.id.cart_recycler);
		//price_info_total = findViewById(R.id.price_info_total);
		order_address = findViewById(R.id.order_address);
		//	delivery_charge_info = findViewById(R.id.delivery_charge_info);
		order_success = findViewById(R.id.order_success);
		//	offer_details_text = findViewById(R.id.offer_details_text);

		//highlight
		payment_mode_change = findViewById(R.id.payment_mode_change);
		subtotal_price = findViewById(R.id.subtotal_price);
		offers_applied_price = findViewById(R.id.offers_applied_price);
		shipping_price = findViewById(R.id.shipping_price);
		total_price_cart = findViewById(R.id.total_price_cart);
		order_qual_text = findViewById(R.id.order_qual_text);

		order_qual_text.setVisibility(View.VISIBLE);

		if (getSupportActionBar() != null)
			getSupportActionBar().setTitle("Cart");

		adapter = new CartAdapter(this, position -> updateTotal());
		recyclerView.setLayoutManager(new LinearLayoutManager(this));
		recyclerView.setAdapter(adapter);
		adapter.notifyDataSetChanged();

		checkOffers(); //highlight : entry point, first load all offers then calculate all, updating will be total based

		order_success.setOnClickListener(v -> {
			if (verifyOrders()) {
				if (verifyAddress()) {
					pickupTime();
				} else
					Toast.makeText(CartActivity.this, "Bad delivery location, please update location!", Toast.LENGTH_SHORT).show();
			} else
				Toast.makeText(CartActivity.this, reason, Toast.LENGTH_SHORT).show();
		});
	}

	private boolean verifyAddress() {
		double latitude = LocalDatabase.getInstance(getBaseContext()).getLatitude();
		double longitude = LocalDatabase.getInstance(getBaseContext()).getLongitude();

		String address = LocalDatabase.getInstance(getBaseContext()).getLastAddress();

		return latitude > 0d && longitude > 0d && (address != null && !address.isEmpty() && !address.equals("null"));
	}

	private void pickupTime() {
		Calendar now = Calendar.getInstance();
		TimePickerDialog dialog = TimePickerDialog.newInstance(this,
				now.get(Calendar.HOUR_OF_DAY),
				now.get(Calendar.MINUTE),
				now.get(Calendar.SECOND),
				false);
		dialog.setMaxTime(22, 59,
				59);
		dialog.setMinTime(10, 0, 0);
		dialog.show(getSupportFragmentManager(), "When do you want to get the food?");
		Toast.makeText(CartActivity.this, "When do you want to get the food?", Toast.LENGTH_LONG).show();
	}

	private boolean verifyOrders() {
		if (LocalOrderSystem.getOrders().size() < 1) {
			reason = "Cart is empty!";
			return false;
		}
		int totallySingleOrderable = 0;

		for (LocalOrders order : LocalOrderSystem.getOrders()) {
			if (!order.isSingleOrderable() && LocalOrderSystem.getOrders().size() == 1) {
				reason = order.getFood_name() + " can't be ordered as single order";
				return false;
			} else if (!order.isSingleOrderable()) {
				reason = order.getFood_name() + " can't be ordered as single order, add more normal orders";
			} else {
				totallySingleOrderable++;
			}
		}
		reason = "Sorry, add food orders to checkout!";

		double dis = LocalDatabase.getInstance(getBaseContext()).getDistance();

		if (dis <= 2 && total_charge_to_pay <= 50) {
			reason = "Sorry, minimum ₹50 order for less than 2km delivery";
			return false;
		} else if (total_charge_to_pay <= 100) {
			reason = "Sorry, minimum ₹100 order for delivery";
			return false;
		}

		return totallySingleOrderable > 0;
	}

	private void checkOffers() {
		offer_Dialogue = new AlertDialog.Builder(CartActivity.this)
				.setView(R.layout.offer_dialogue)
				.create();

		if (!this.isFinishing())
			offer_Dialogue.show();

		OfferManager manager = OfferManager.getInstance();

		boolean testMode = false; //test?

		DatabaseConstants.getFDB()
				.collection(testMode ? DatabaseConstants.TEST_OFFERS :
						DatabaseConstants.MAIN_OFFERS)
				.get()
				.addOnSuccessListener(queryDocumentSnapshots -> {
					List<DocumentSnapshot> dcs = queryDocumentSnapshots
							.getDocuments();

					DocumentSnapshot ref = null;
					if (dcs.size() > 0) {
						for (DocumentSnapshot snapshot : dcs) {
							start = Long.parseLong(String.valueOf(snapshot.get(DatabaseConstants.OFFER_START)));
							end = Long.parseLong(String.valueOf(snapshot.get(DatabaseConstants.OFFER_EXPIRY)));
							if (end > start && System.currentTimeMillis() > start && System.currentTimeMillis() < end) {
								ref = snapshot;
								manager.setOfferAvailable(true);

								long offerAmt = Long.parseLong(String.valueOf(ref.get(DatabaseConstants.OFFER_AMOUNT)));
								manager.setOfferAmt_common(offerAmt);

								ArrayList<Long> fd_all = (ArrayList<Long>) ref.get(DatabaseConstants.OFFER_FOOD_LIST);
								if (fd_all != null) {
									if (fd_all.size() == 1 && fd_all.get(0) == -1L) {
										manager.setAllFoodsUnderOffer(true);
									} else {
										manager.setAllFoodsUnderOffer(false);
										manager.setFoods_all(fd_all);
									}
								} else {
									manager.setOfferAvailable(false);
								}
								break;
							}
						}
						if (ref == null) {
							manager.setOfferAvailable(false);
						}
					} else {
						manager.setOfferAvailable(false);
					}
					updateTotal();
				});
	}


	@SuppressLint("SetTextI18n")
	private void updateTotal() {

		long total_price = 0;
		int delivery_charge;

		total_charge_to_pay = 0;

		long totalOfferValue = 0L;

		OfferManager manager = OfferManager.getInstance();

		for (LocalOrders order : LocalOrderSystem.getOrders()) {
			total_price += order.getFood_price() * order.getFood_count();

			if (manager.isOfferAvailable() && manager.isAllFoodsUnderOffer()) {
				totalOfferValue = totalOfferValue + (long) (total_price * (manager.getOfferAmt() / 100.0f));
			} else if (manager.isOfferAvailable() && manager.getFoods_all().contains(order.getItem_id())) {
				totalOfferValue = totalOfferValue + (long) (total_price * (manager.getOfferAmt() / 100.0f));
			}
		}

		delivery_charge = Math.max(((int) Math.floor(LocalDatabase.getInstance(getBaseContext()).getDistance()
				* 1.25 * DatabaseConstants.DELIVERY_CHARGE_PER_KM)), 6);

		total_charge_to_pay = total_price + delivery_charge - totalOfferValue;

		subtotal_price.setText("₹" + total_price);
		offers_applied_price.setText("-₹" + totalOfferValue);
		shipping_price.setText("+₹" + delivery_charge);
		total_price_cart.setText("₹" + total_charge_to_pay);

		order_address.setText(new StringBuilder(LocalDatabase.getInstance(getBaseContext()).getLastAddress())
				.append("\n")
				.append("; - ")
				.append(LocalDatabase.getInstance(getBaseContext()).getLandmark() != null &&
						!LocalDatabase.getInstance(getBaseContext()).getLandmark().equalsIgnoreCase("") ?
						LocalDatabase.getInstance(getBaseContext()).getLandmark() : "(Landmark) Not Provided"));

		order_success.setText("Checkout ₹" + total_charge_to_pay);

		if (!this.isFinishing() && offer_Dialogue.isShowing())
			offer_Dialogue.dismiss();
	}

	private void launchPaymentAndOrder(Calendar then) {
		paymentDialogue = getPaymentDialogue(then);
		if (!paymentDialogue.isShowing() && !isFinishing())
			paymentDialogue.show();
	}

	private AlertDialog getPaymentDialogue(Calendar then) {
		View view = getLayoutInflater().inflate(R.layout.payment_card, null);

		MaterialCardView gPay_pay, cod_pay;

		gPay_pay = view.findViewById(R.id.gpay_pay);
		cod_pay = view.findViewById(R.id.cod_pay);

		gPay_pay.setOnClickListener(v -> setupGPay(then));
		cod_pay.setOnClickListener(v -> setupCOD(then));

		return new AlertDialog.Builder(this)
				.setView(view)
				.setTitle("Payment Mode")
				.setIcon(R.drawable.ic_pay_choice)
				.create();
	}

	private void setupCOD(Calendar then) {
		executeOrder(DatabaseConstants.PAYMENT_MODE_COD, System.currentTimeMillis(), then.getTimeInMillis());
		if (paymentDialogue != null && paymentDialogue.isShowing())
			paymentDialogue.dismiss();
	}

	@SuppressLint("SetTextI18n")
	private void setupGPay(Calendar then) {
		View view = getLayoutInflater().inflate(R.layout.g_pay_dialogue, null);

		ImageView imageView = view.findViewById(R.id.g_pay_image);
		TextView textView = view.findViewById(R.id.payment_info_total);

		textView.setText("Send ₹ " + total_charge_to_pay + ".00" + " to this account\nOrder will be accepted after payment!");

		g_pay_dialogue = new AlertDialog.Builder(this)
				.setView(view)
				.setPositiveButton("Confirm", (dialog, which) ->
						executeOrder(DatabaseConstants.PAYMENT_MODE_G_PAY, System.currentTimeMillis(),
								then.getTimeInMillis()))
				.setNegativeButton("Cancel", null)
				.setCancelable(false)
				.create();

		Glide.with(this)
				.load(FirebaseAccess.GPay_Info())
				.into(imageView);

		if (paymentDialogue != null && paymentDialogue.isShowing())
			paymentDialogue.dismiss();
		if (g_pay_dialogue != null && !this.isFinishing()) {
			g_pay_dialogue.show();
			FirebaseAccess.getPaymentAddress(id -> {
				ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
				ClipData clip = ClipData.newPlainText("phone", id);
				clipboard.setPrimaryClip(clip);
				Toast.makeText(this, "Phone Number Copied To Clipboard", Toast.LENGTH_SHORT).show();
			});
		}
	}

	private void executeOrder(int mode, long order_number, long timeInMillis) {
		if (LocalDatabase.getInstance(getBaseContext()).getOrdersEnabled())
			FoodOrderManager.activateOnce(getBaseContext());
		FoodOrderManager.place(CartActivity.this, mode, order_number, timeInMillis,
				new FoodOrderManager.OrderPlacingListener() {
					@Override
					public void onOrderPlaced() {
						LocalOrderSystem.removeOrdersAll(new LocalOrderSystem.LocalOrderSystemListener() {
							@SuppressLint("NotifyDataSetChanged")
							@Override
							public void onSuccess() {
								adapter.notifyDataSetChanged();
								updateTotal();
								Toast.makeText(CartActivity.this, "Order Placed Successfully!", Toast.LENGTH_SHORT).show();
							}

							@SuppressLint("NotifyDataSetChanged")
							@Override
							public void onFailure() {
								adapter.notifyDataSetChanged();
								updateTotal();
								Toast.makeText(CartActivity.this, "Order Placed Successfully , please clear cart manually!", Toast.LENGTH_SHORT).show();
							}
						});
					}

					@Override
					public void onOrderPlaceFailed(Exception e) {
						e.printStackTrace();
						Toast.makeText(CartActivity.this, "Order Removal Failed, Contact Support", Toast.LENGTH_SHORT).show();
					}
				});
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.menu.main_cart, menu);
		return super.onCreateOptionsMenu(menu);
	}

	@Override
	public boolean onOptionsItemSelected(@NonNull MenuItem item) {
		if (item.getItemId() == R.id.action_exit)
			finish();
		return super.onOptionsItemSelected(item);
	}

	@Override
	protected void onPause() {
		if (paymentDialogue != null && paymentDialogue.isShowing())
			paymentDialogue.dismiss();
		if (offer_Dialogue != null && offer_Dialogue.isShowing())
			offer_Dialogue.dismiss();
		super.onPause();
	}

	@Override
	protected void onDestroy() {
		super.onDestroy();
	}

	@Override
	public void onTimeSet(TimePickerDialog view, int hourOfDay, int minute, int second) {
		Calendar now = Calendar.getInstance();
		Calendar then = Calendar.getInstance();

		then.set(Calendar.HOUR_OF_DAY, hourOfDay);
		then.set(Calendar.MINUTE, minute);
		then.set(Calendar.SECOND, second);

		long seconds = (then.getTimeInMillis() - now.getTimeInMillis()) / 1000;
		int minutes = (int) (seconds / 60);

		if (then.getTimeInMillis() < now.getTimeInMillis() ||
				(then.get(Calendar.HOUR_OF_DAY) > 22) || minutes < 30) {
			Toast.makeText(CartActivity.this, "Pick a time 30 minutes later from now & before 10pm", Toast.LENGTH_SHORT).show();
			pickupTime();
			return;
		}
		launchPaymentAndOrder(then);
	}
}